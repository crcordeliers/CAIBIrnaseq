---
title: "Unsupervised RNA-seq analysis"
author: "Cordeliers Artificial Intelligence and Bioinformatics"
date: "`r Sys.Date()`"
format: 
  html:
    toc: true
    embed-resources: true
editor: source
---

```{r}
#| message: false
library(airway)
library(SummarizedExperiment)
```


```{r read_params}
#| message: false

species <- "Homo sapiens"

# Variable d'annotation à visualiser (colData(airway))
plot_annotations <- "dex"  # traitement au dexaméthasone

# Paramètres de qualité (QC)
qc_min_nsamp <- 2
qc_min_gene_counts <- 10  # valeur un peu plus élevée pour un jeu réel

# Clustering d'expression
exp_cluster <- data.frame(k = 2)

# Clustering des métadonnées
metadata_clusters <- list(
  pathway_scores = data.frame(k = 2),
  microenv_scores = data.frame(k = 3)
)


# Collections de pathways (humaines)
pathway_collections <- "CP:KEGG_LEGACY"  # KEGG tout court est plus standard pour Homo sapiens

# Gènes pertinents dans airway pour les heatmaps (liés au métabolisme, réponse au stress, etc.)
heatmap_genes <- list(
  c("NR3C1", "FKBP5", "TSC22D3", "ZBTB16", "PER1"),  # gènes régulés par le glucocorticoïde
  c("CYP1B1", "G6PD", "HMOX1", "NQO1", "SOD2")       # stress oxydatif / métabolisme
)

# Exemples de pathways (à adapter selon les résultats d'analyse)
heatmap_pathways <- c(
  "KEGG_APOPTOSIS",
  "KEGG_GLUTATHIONE_METABOLISM"
)

# Gènes pour les boxplots (fortement exprimés et différentiels)
boxplot_genes <- c("FKBP5", "TSC22D3")

# Pathways pour les boxplots
boxplot_pathways <- c(
  "KEGG_APOPTOSIS",
  "KEGG_GLUTATHIONE_METABOLISM"
)

# Corrélations entre gènes
correlation_genes <- list(
  c("FKBP5", "TSC22D3"),
  c("FKBP5", "ZBTB16")
)

# Corrélations entre pathways
correlation_pathways <- list(
  c("KEGG_APOPTOSIS", "KEGG_GLUTATHIONE_METABOLISM"),
  c("KEGG_APOPTOSIS", "KEGG_NOD_LIKE_RECEPTOR_SIGNALING_PATHWAY")
)

```

```{r dependencies}
#| message: false
library(CAIBIrnaseq)
```

## Load data

This section loads the RNA-seq dataset for analysis. It ensures the correct input file is used, as specified in the parameters.
rebase_gexp
```{r load_data}
#| message: false
data(airway, package="airway")
exp_data <- airway

rowData(exp_data)$gene_length_kb <- 
  (rowData(exp_data)$gene_seq_end - rowData(exp_data)$gene_seq_start) / 1000

library(biomaRt)

# Initialiser biomaRt pour Ensembl humain
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Obtenir les descriptions basées sur les gene_id
gene_ids <- rowData(exp_data)$gene_id

annot <- getBM(attributes = c("ensembl_gene_id", "description"),
               filters = "ensembl_gene_id",
               values = gene_ids,
               mart = mart)

# Faire correspondre les descriptions aux lignes de rowData
matched <- match(rowData(exp_data)$gene_id, annot$ensembl_gene_id)
rowData(exp_data)$gene_description <- annot$description[matched]
```

## Pre-processing

Most datasets use ensemble gene ID by default after alignment, so this step rebases the expression data to gene names. This ensures consistency in naming for downstream analyses.

```{r rebase_gexp}
#| message: false
exp_data <- rebase_gexp(exp_data, annotation = "gene_name")
```

### Filter

Here, we filter out genes expressed in too few samples or with very low counts. This removes noise from the data and focuses on meaningful gene expressions.

```{r filter_gexp}
#| message: false
exp_data <- filter_gexp(exp_data,
                        min_nsamp = 1, 
                        min_counts = 1)
```
diffexp <- diffExpAnalysis(countData = SummarizedExperiment::assays(exp_data)$counts, sampleInfo = SummarizedExperiment::colData(exp_data), method = diffexpMethod, cutoff = 10, design, coefname)
Visualization of the filtering process to ensure the criteria applied align with the dataset’s characteristics:

```{r plot_qc_filters}
#| message: false
colData(exp_data)$sample_id <- colnames(exp_data)
plot_qc_filters(exp_data)
```

### Normalize

Here, we apply a normalization to the expression data, making samples comparable by reducing variability due to technical differences. For datasets with few samples, `rlog` is the preferred normalization and when more samples are present, `vst` is applied.
class(exp_data)
```{r}
#| message: false
exp_data <- normalize_gexp(exp_data)
```

## PCA

Principal component analysis (PCA) identifies the major patterns in the dataset. These patterns help explore similarities or differences among samples based on gene expression.

```{r}
#| message: false
pca_res = pca_gexp(exp_data)
exp_data@metadata[["pca_res"]] <- pca_res

annotations <- setdiff(plot_annotations, c("exp_cluster", "path_cluster"))
plot_pca(exp_data, color = plot_annotations)
```
```{r}
library(factoextra)
groups <- SummarizedExperiment::colData(exp_data)$dex  # ou le nom réel de la colonne indiquant STING_KO/Wild_type

fviz_pca_ind(pca_res,
             geom = "point",
             habillage = groups,
             palette = c("#00AFBB", "#E7B800"),  # couleurs personnalisées
             addEllipses = TRUE,
             ellipse.type = "confidence",
             repel = TRUE,
             label = "none"
)
```


## Unsupervised clustering

Here, we group samples based on expression patterns without prior knowledge using hierarchical clustering on either a selected gene list from the parameters or, by default, the 2000 most highly expressed genes.

This can be useful for discovering sample subgroups or new biological insights.

```{r}
#| message: false
#| label: exp cluster
#| eval: !expr is.list(exp_cluster)
exp_data <- cluster_exp(exp_data, k = exp_cluster$k, genes = exp_cluster$genes, n_pcs = 3)
```

Visual representation of expression levels for HVG across clusters, highlighting distinct patterns.

```{r}
#| label: plot hvg
#| fig.width: 8
#| fig.height: 5
hvg <- highly_variable_genes(exp_data)
exp_cluster <- data.frame(k = 2)
hm <- plot_exp_heatmap(exp_data,  genes = hvg, 
                 annotations = c(plot_annotations, "exp_cluster"),
                 show_rownames = FALSE,
                 hm_color_limits = c(-2,2),
                 fname = "results/clustering/heatmap_2000hvg_exp_cluster.pdf")
```

## Pathway activity

Pathway analysis enables us to understand the functional implications of gene expression changes. Here, we analyze the dataset for pathway activity using two methods.

### PROGENy

PROGENy is a collection of only 14 core pathway responsive genes from large signaling perturbation experiments. For more information see the [original paper](https://www.nature.com/articles/s41467-017-02391-6).

```{r}
#| message: false
#| label: progenyprovided
progeny_scores <- score_progeny(exp_data, species = "Homo sapiens")

tmp <- S4Vectors::metadata(exp_data)          # récupère une liste depuis exp_data
tmp[["progeny_scores"]] <- progeny_scores  # modifie cette liste
S4Vectors::metadata(exp_data) <- tmp  

plot_progeny_heatmap(exp_data, annotations = plot_annotations,
                     fname = "results/pathways/hm_progeny_scores.pdf")
write.csv(progeny_scores, file = "results/pathways/progeny_scores.csv")
```

### Pathways

Pathway collections available in the MSIGdb can be specified in the parameters. These pathways are scored and ranked by their variance in the data. These are the available collections (use `gs_subcat` as name except for Hallmarks, which should be 'H').

```{r}
#| message: false
#| label: collections
msigdbr::msigdbr_collections() |> kableExtra::kbl() |> kableExtra::kable_styling() |> kableExtra::scroll_box(height = "300px")
```

```{r}
#| message: false
SummarizedExperiment::rowData(exp_data)
```


```{r}
#| message: false
#| label: pathways
#| fig-width: 10
#| fig-height: 5

pathways <- get_annotation_collection(pathway_collections, 
                                      species = species)
pathway_scores <- score_pathways(exp_data, pathways, verbose = FALSE)
S4Vectors::metadata(exp_data)[["pathway_scores"]] <- pathway_scores

collections <- pathway_collections |> 
  paste(collapse = "_") |>
  stringr::str_remove("\\:")

plot_pathway_heatmap(exp_data, annotations = plot_annotations,
                    fwidth = 9,
                    fname = stringr::str_glue(
                      "results/pathways/hm_paths_{collections}_top20.pdf")
                    )
write.csv(pathways, file = stringr::str_glue("results/pathways/paths_{collections}.csv"))
```

## Microenvironment scores

This step calculates immune and stromal cell type abundances using MCPcounter or mMCPcounter. It helps to infer the composition of the tumor microenvironment or similar contexts.

```{r}
#| message: false
#| label: microenvironment
mcp_scores <- mcp_counter(exp_data, species = species)
S4Vectors::metadata(exp_data)[["microenv_scores"]] <- mcp_scores

plot_microenv_heatmap(exp_data, annotations = c("dex", "exp_cluster"),
                      fname = "results/tme/heatSmap_mcpcounter.pdf")
write.csv(mcp_scores, file = "results/tme/scores_mcpcounter.csv")
```

## Targeted plots

This section focuses on visualizing specific genes or pathways of interest, as specified in the parameters.

### Heatmaps

Generates heatmaps for pre-selected genes of interest to observe their expression across samples or conditions.


```{r}
#| message: false
#| label: plot_hm_genes
#| fig-width: 10
#| fig-height: 4

hms <- lapply(1:length(heatmap_genes), function(i) {
  gene_annot <- SummarizedExperiment::rowData(exp_data)
  genes <- heatmap_genes[[i]]
  name <- ifelse(is.null(names(heatmap_genes)), i, names(heatmap_genes)[i])
  plot_exp_heatmap(exp_data, genes = genes, 
                   annotations = plot_annotations,
                   fname = stringr::str_glue("results/targeted/hm_genes_{i}.pdf"))
})
patchwork::wrap_plots(hms, ncol = 2, guides = "collect")
```

#### Selected pathways

```{r}
#| message: false
#| label: plot_hm_pathways
#| fig-width: 7
#| fig-height: 4

valid_pathways <- intersect(heatmap_pathways, rownames(pathway_scores))

plot_pathway_heatmap(exp_data, 
                     annotations = plot_annotations, 
                     pathways = valid_pathways,
                     fname = stringr::str_glue("results/targeted/hm_pathways_selected.pdf"))
```

### Boxplots

Boxplots provide a clear comparison of expression levels across experimental groups or conditions.

#### Selected genes

```{r}
#| message: false
#| label: plot_box_genes
#| message: true
#| warning: false
genes <- boxplot_genes
annotations <- plot_annotations

boxplots <- lapply(genes, function(gene) {
  lapply(annotations, function(annotation) {
    plt <- plot_exp_boxplot(exp_data, gene = gene, 
                   annotation = annotation, 
                   color_var = annotation, 
                   pt_size = 2,
                   fname = stringr::str_glue("results/targeted/boxplots/box_{gene}_{annotation}.pdf"))
  })
}) |> purrr::flatten()
```

```{r}
#| message: false
#| label: plot_box_genes2
#| fig-width: 10
#| fig-height: 4
patchwork::wrap_plots(boxplots, nrows = round(length(boxplots)/2), guides = "collect")
```

#### Selected pathways

```{r}
#| label: plot_box_paths
#| message: false
#| warning: false
paths <- boxplot_pathways
annotations <- plot_annotations

boxplots <- lapply(paths, function(path) {
  lapply(annotations, function(annotation) {
    plt <- plot_path_boxplot(exp_data, 
                             pathway = path,
                   annotation = annotation, 
                   color_var = annotation, 
                   pt_size = 2,
                   fname = stringr::str_glue("results/targeted/boxplots/box_{path}_{annotation}.pdf"))
  })
}) |> purrr::flatten()
```

```{r}
#| label: plot_box_paths2
#| fig-width: 10
#| fig-height: 4
#| message: false
patchwork::wrap_plots(boxplots, nrows = round(length(boxplots)/2), guides = "collect")
```

### Correlations

This section visualizes relationships between pairs of genes or pathways by plotting their expression/activity correlations. Correlation analysis can reveal important co-regulation or interaction patterns, helping to uncover biologically meaningful relationships.

#### Selected genes

Here we plot the correlation between selected gene pairs across the dataset. Each pair is plotted separately, and color-coded by sample annotation.

```{r}
#| message: false
#| label: plot_correlation_genes

gene_pairs <- correlation_genes
annotations <- plot_annotations

cor_plts <- lapply(gene_pairs, function(gene_pair) {
  lapply(annotations, function(annot) {
      plot_exp_scatter(exp_data, 
                   gene1 = gene_pair[1],
                   gene2 = gene_pair[2], 
                   color_var = annot,
                   fname = stringr::str_glue(
                     "results/targeted/correlations/cor_{gene_pair[1]}_{gene_pair[2]}_color={annot}.pdf"))
  })
}) |> purrr::flatten()
```

```{r}
#| message: false
#| label: plot_correlation_genes2
#| fig-width: 10
#| fig-height: 4
patchwork::wrap_plots(cor_plts, nrows = round(length(cor_plts)/2), guides = "collect")
```

#### Selected pathways

Correlation plots for selected pathways can help identify similarities or differences in pathway activity patterns across samples. Each pathway pair is plotted separately and color-coded by sample annotation to illustrate trends within each condition.

```{r}
#| message: false
#| label: plot_correlation_paths

path_pairs <-correlation_pathways
annotations <- plot_annotations

cor_plts <- lapply(path_pairs, function(path_pair) {
  lapply(annotations, function(annot) {
      plot_path_scatter(exp_data, 
                   pathway1 = path_pair[1],
                   pathway2 = path_pair[2], 
                   color_var = annot,
                   fname = stringr::str_glue(
                     "results/targeted/correlations/cor_{path_pair[1]}_{path_pair[2]}_color={annot}.pdf"))
  })
}) |> purrr::flatten()
```

```{r}
#| message: false
#| label: plot_correlation_paths2
#| fig-width: 10
#| fig-height: 4
patchwork::wrap_plots(cor_plts, nrows = round(length(cor_plts)/2), guides = "collect")
```

## Cluster using metadata

```{r}
#| message: false
#| label: cluster_metadata
#| warning: false
types = names(metadata_clusters)

for(type in types) {
  exp_data <- cluster_metadata(exp_data, 
                   metadata_name = type, 
                   k = metadata_clusters[[type]]$k, 
                   features = metadata_clusters[[type]]$features,
                   n_pcs = 3 )
}
```

## Save SummarizedExperiment

The final step saves the processed dataset and results. This ensures all outputs can be revisited or shared for further analysis.

```{r}
#| message: false
saveRDS(exp_data, file = stringr::str_glue("results/data_SummarizedExp_{lubridate::today()}.RDS"))
```

## Report parameters

For reproducibility, the parameters used in the analysis and the computational environment details are documented.

### sessionInfo

The `sessionInfo()` prints out all packages loaded at the time of analysis, as well as their versions.

```{r}
sessionInfo()
```

